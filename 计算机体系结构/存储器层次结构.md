
----
- ### block placement
	- 全相联Fully associative
	- 直接相联direct mapped
	- 组相联n-way set associative
- ### block identification
	- 直接相关和组相关
		- 标志tag：通过比较标志字段，检查组内是否有匹配块(是否命中)
		- 索引index：用来选择组别，全相联没有这项
		- 块偏移block offset：块内偏移地址，确定需要访问数据在Cache块内的地址
		- ![[Pasted image 20221223162711.png]]
	- 全相关
		- 每个block都要进行标志tag比较，为了速度需要并行比较
		- 要给每个 block配置一个比较器，用于标志比较
		- ![[Pasted image 20221223163302.png]]

- ### block replacement
	- #### 方法
		- 直接相联
			- 利用模运算直接映射
		- 组相联和全相联
			- 随机算法
				- 随机选择一块被替换
			- LRU算法
				- 基本思想是近期被用到的块大概率还会被再次使用，所以选择近期最久没用的块当做被替换的块
			- FIFO算法
				- 最先进来的块被替换
	- #### 比较
		- 相同Cache大小情况下，相联度增加(每组包含的Cache块数增加)，不命中次数下降
		- 对于大尺寸Cache，LRU与随机算法性能差不多。但是，对于小尺寸Cache，LRU性能优于其他两种算法
		- 对于小尺寸Cache，FIFO性能优于随机算法。
- ### write strategy
	- 写直达法write-through
		- 在更新Cache数据时，同步更新内存数据
	- 写回法write-back
		- 只有当Cache块被替换时，才更新内存的相应数据
	- #### 比较
		- 如果数据改变多次，写直达法多次会写内存，写回法则不会
		- 写直达法与内存通信量大，写回法与内存通信量小，比较适合嵌入式应用
		- 写直达法能较好保持数据一致性，更加便宜实现多级Cache。因为只需要保持与相邻级Cache数据一致，不用一直追溯到内存
		- 写直达法实现比较容易

-----

## 优化方法
- ### 基本优化方法
	- #### 更大的块尺寸
		- 减少首次访问不命中。更大的块尺寸可以利用程序的时间局部性(空间邻近指令被访问的时间也会比较接近。块尺寸更大，取入更多相邻数据，它们有很大概率会很快被访问，由于被取入Cache，避免了这些相邻数据的首次访问不命中)
		- 增加映射冲突不命中(Cache块变大，数量变少，映射冲突加剧)，增加容量导致不命中，增加不命中时间开销
	- #### 增加Cache容量减少不命中率(将更多数据装入Cache)
		- 会增加命中时间(Cache变大查找比较时间增多)，增加能耗
	- #### 更高的相联度(每组包含更多块)
		- 减少冲突导致的不命中(每组块数量增加，冲突减少)
		- 增加命中时间，增加能耗
	- #### 更多Cache级数
		- 减少整体存储器访问时间，增加硬件开销
	- #### 避免在Cache检索时采用地址译码，减少命中时间
	- #### 给读不命中(Read miss)赋予高于写(通过Writer buffer更新内存)的优先级，减少不命中时间开销(Miss penalty)
		- 有时发生读不命中时，需要的数据在写缓冲器(Writer buffer)中，先检查写缓冲器内容以满足读命中需要
- ### 高级优化方法
	- #### 减少命中时间
		- 小容量L1 Cache
		- 组内块(路)预测
	- #### 增加Cache带宽
		- 流水线结构Cache
		- 多缓存组Cache
		- 无阻塞Cache
	- #### 减少不命中时间开销
		- 关键字优先
		- 合并写缓冲器
	- #### 减少不命中率
		- 编译器优化
	- #### 利用并行性减少不命中时间开销和不命中率
		- 硬件预取
		- 编译器预取